<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XLSParser: XLSParser.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">XLSParser
   </div>
   <div id="projectbrief">Библиотека для считывания текстовых данных из файлов формата XLS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">XLSParser.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;Windows.h&gt;</code><br />
<code>#include &lt;bit&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for XLSParser.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp__incl.png" border="0" usemap="#a_x_l_s_parser_8cpp" alt=""/></div>
</div>
</div>
<p><a href="_x_l_s_parser_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_f_header.html">CFHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Представляет заголовок Compound File (CF), используемый в формате Compound File Binary Format (CFBF).  <a href="struct_c_f_header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_directory_entry.html">DirectoryEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Представляет запись каталога в формате Compound File Binary Format (CFBF).  <a href="struct_directory_entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_record_head.html">RecordHead</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Заголовок записи в структуре данных документа Compound File Binary Format (CFBF).  <a href="struct_record_head.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ws_bool.html">WsBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Флаги настроек рабочего листа в формате Excel.  <a href="struct_ws_bool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_x_l_u_s.html">SXLUS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Структура для представления строки в формате Excel.  <a href="struct_s_x_l_u_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_bound_sheet8.html">BoundSheet8</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Структура для представления метаданных о листе в файле Excel.  <a href="struct_bound_sheet8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_l_u_r_e_s.html">XLURES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Представляет строку в формате BIFF (Binary Interchange File Format) Excel.  <a href="struct_x_l_u_r_e_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_s_t.html">SST</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Структура, представляющая таблицу строк (String Table) в формате BIFF (Binary Interchange File Format) для Excel.  <a href="struct_s_s_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1f60f20a364269797af8f667e0e0d3dd" id="r_a1f60f20a364269797af8f667e0e0d3dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f60f20a364269797af8f667e0e0d3dd">isEqualArr</a> (BYTE *arr1, BYTE *arr2, DWORD size)</td></tr>
<tr class="memdesc:a1f60f20a364269797af8f667e0e0d3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сравнивает два массива байтов на равенство.  <br /></td></tr>
<tr class="separator:a1f60f20a364269797af8f667e0e0d3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac462abe109e1ef9562149cb5362f87b5" id="r_ac462abe109e1ef9562149cb5362f87b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac462abe109e1ef9562149cb5362f87b5">ReadSector</a> (void *dst, BYTE *buf, DWORD secNum, DWORD size)</td></tr>
<tr class="memdesc:ac462abe109e1ef9562149cb5362f87b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Читает данные сектора из буфера в указанную область памяти.  <br /></td></tr>
<tr class="separator:ac462abe109e1ef9562149cb5362f87b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0b8d48ed8464d0e2208e4e35583a0d" id="r_aec0b8d48ed8464d0e2208e4e35583a0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec0b8d48ed8464d0e2208e4e35583a0d">getDIFATChain</a> (DWORD *dst, <a class="el" href="struct_c_f_header.html">CFHeader</a> *cfh, BYTE *buf, DWORD secSize)</td></tr>
<tr class="memdesc:aec0b8d48ed8464d0e2208e4e35583a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Извлекает цепочку DIFAT секторов и сохраняет их в массив.  <br /></td></tr>
<tr class="separator:aec0b8d48ed8464d0e2208e4e35583a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72dbc33b77d2c5e83ddd6751866e3b7d" id="r_a72dbc33b77d2c5e83ddd6751866e3b7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72dbc33b77d2c5e83ddd6751866e3b7d">getFATChain</a> (DWORD *dst, DWORD *difCh, <a class="el" href="struct_c_f_header.html">CFHeader</a> *cfh, BYTE *buf, DWORD secSize)</td></tr>
<tr class="memdesc:a72dbc33b77d2c5e83ddd6751866e3b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Извлекает цепочку FAT секторов и сохраняет их в массив.  <br /></td></tr>
<tr class="separator:a72dbc33b77d2c5e83ddd6751866e3b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3835c3169fc0f7dd1ef7f64c5273d877" id="r_a3835c3169fc0f7dd1ef7f64c5273d877"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3835c3169fc0f7dd1ef7f64c5273d877">getWorkbookChain</a> (DWORD *dst, DWORD *fatCh, <a class="el" href="struct_directory_entry.html">DirectoryEntry</a> *de, DWORD chainSize, DWORD secSize, BYTE *buf)</td></tr>
<tr class="memdesc:a3835c3169fc0f7dd1ef7f64c5273d877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Извлекает цепочку секторов книги из FAT и сохраняет их в массив.  <br /></td></tr>
<tr class="separator:a3835c3169fc0f7dd1ef7f64c5273d877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700d13c54a8be00c596a541be2dc97ce" id="r_a700d13c54a8be00c596a541be2dc97ce"><td class="memItemLeft" align="right" valign="top">HANDLE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a700d13c54a8be00c596a541be2dc97ce">openFile</a> (const wchar_t *filename)</td></tr>
<tr class="memdesc:a700d13c54a8be00c596a541be2dc97ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Открывает файл для чтения.  <br /></td></tr>
<tr class="separator:a700d13c54a8be00c596a541be2dc97ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2135890fef23bcc112b0a236b9b6c20c" id="r_a2135890fef23bcc112b0a236b9b6c20c"><td class="memItemLeft" align="right" valign="top">BYTE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2135890fef23bcc112b0a236b9b6c20c">getData</a> (HANDLE fileHandle)</td></tr>
<tr class="memdesc:a2135890fef23bcc112b0a236b9b6c20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Читает данные из файла в буфер.  <br /></td></tr>
<tr class="separator:a2135890fef23bcc112b0a236b9b6c20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff033cf1fdd9f4bdae4177c562eaa5c7" id="r_aff033cf1fdd9f4bdae4177c562eaa5c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_f_header.html">CFHeader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff033cf1fdd9f4bdae4177c562eaa5c7">readHeader</a> (BYTE *buf)</td></tr>
<tr class="memdesc:aff033cf1fdd9f4bdae4177c562eaa5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Читает заголовок из буфера и возвращает указатель на структуру <a class="el" href="struct_c_f_header.html" title="Представляет заголовок Compound File (CF), используемый в формате Compound File Binary Format (CFBF).">CFHeader</a>.  <br /></td></tr>
<tr class="separator:aff033cf1fdd9f4bdae4177c562eaa5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1433e87475b32499d3375087cffbd1" id="r_a9f1433e87475b32499d3375087cffbd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f1433e87475b32499d3375087cffbd1">checkSig</a> (<a class="el" href="struct_c_f_header.html">CFHeader</a> *cfh)</td></tr>
<tr class="memdesc:a9f1433e87475b32499d3375087cffbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Проверяет подпись заголовка файла для подтверждения формата Compound File.  <br /></td></tr>
<tr class="separator:a9f1433e87475b32499d3375087cffbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0ff8adaff08621b6eac375c9262e18" id="r_a2b0ff8adaff08621b6eac375c9262e18"><td class="memItemLeft" align="right" valign="top">DWORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b0ff8adaff08621b6eac375c9262e18">countDESectors</a> (DWORD fstDELoc, BYTE *buf, DWORD *fatCh, DWORD secSize)</td></tr>
<tr class="memdesc:a2b0ff8adaff08621b6eac375c9262e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Подсчитывает количество секторов, связанных с цепочкой Directory Entry (DE).  <br /></td></tr>
<tr class="separator:a2b0ff8adaff08621b6eac375c9262e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77afacbaeb29cd296eb5dd6f3f64e00" id="r_ab77afacbaeb29cd296eb5dd6f3f64e00"><td class="memItemLeft" align="right" valign="top">DWORD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab77afacbaeb29cd296eb5dd6f3f64e00">getDEChain</a> (DWORD fstDELoc, BYTE *buf, DWORD *fatCh, DWORD secSize, DWORD k)</td></tr>
<tr class="memdesc:ab77afacbaeb29cd296eb5dd6f3f64e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Создает цепочку секторов Directory Entry (DE) из FAT.  <br /></td></tr>
<tr class="separator:ab77afacbaeb29cd296eb5dd6f3f64e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09591ff2fbdc05f25e3569ba3da9671d" id="r_a09591ff2fbdc05f25e3569ba3da9671d"><td class="memItemLeft" align="right" valign="top">DWORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09591ff2fbdc05f25e3569ba3da9671d">getWorkbookDEOffset</a> (DWORD *deChain, DWORD countDESec, BYTE *buf, DWORD secSize)</td></tr>
<tr class="memdesc:a09591ff2fbdc05f25e3569ba3da9671d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Определяет смещение Directory Entry (DE) объекта Workbook в файле.  <br /></td></tr>
<tr class="separator:a09591ff2fbdc05f25e3569ba3da9671d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c59453319a7175976aa689a12ecd94" id="r_aa1c59453319a7175976aa689a12ecd94"><td class="memItemLeft" align="right" valign="top">BYTE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1c59453319a7175976aa689a12ecd94">unpackWBSC</a> (DWORD *wkbkSC, DWORD wbSSize, DWORD secSize, BYTE *buf)</td></tr>
<tr class="memdesc:aa1c59453319a7175976aa689a12ecd94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Распаковывает цепочку секторов Workbook в единый непрерывный буфер.  <br /></td></tr>
<tr class="separator:aa1c59453319a7175976aa689a12ecd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663eab00af52c5789387bddc85355eef" id="r_a663eab00af52c5789387bddc85355eef"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="struct_bound_sheet8.html">BoundSheet8</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a663eab00af52c5789387bddc85355eef">getbs8</a> (BYTE *Workbook, DWORD wbSSize, DWORD secSize, DWORD *outOffset)</td></tr>
<tr class="memdesc:a663eab00af52c5789387bddc85355eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Извлекает массив объектов <a class="el" href="struct_bound_sheet8.html" title="Структура для представления метаданных о листе в файле Excel.">BoundSheet8</a> из данных Workbook.  <br /></td></tr>
<tr class="separator:a663eab00af52c5789387bddc85355eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9c788c5e66bfc234d597ce3e4ca7fe" id="r_a2f9c788c5e66bfc234d597ce3e4ca7fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f9c788c5e66bfc234d597ce3e4ca7fe">printSheetName</a> (vector&lt; <a class="el" href="struct_bound_sheet8.html">BoundSheet8</a> &gt; bsv, DWORD i)</td></tr>
<tr class="memdesc:a2f9c788c5e66bfc234d597ce3e4ca7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Выводит имя листа из вектора <a class="el" href="struct_bound_sheet8.html" title="Структура для представления метаданных о листе в файле Excel.">BoundSheet8</a>.  <br /></td></tr>
<tr class="separator:a2f9c788c5e66bfc234d597ce3e4ca7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ef7395b571ecce29fba836ff37a909" id="r_a68ef7395b571ecce29fba836ff37a909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_s_t.html">SST</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68ef7395b571ecce29fba836ff37a909">getSST</a> (BYTE *Workbook, DWORD wbSSize, DWORD secSize, DWORD offset)</td></tr>
<tr class="memdesc:a68ef7395b571ecce29fba836ff37a909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Извлекает таблицу общих строк (Shared String Table, <a class="el" href="struct_s_s_t.html" title="Структура, представляющая таблицу строк (String Table) в формате BIFF (Binary Interchange File Format...">SST</a>) из Workbook.  <br /></td></tr>
<tr class="separator:a68ef7395b571ecce29fba836ff37a909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd1dfd77f1b9ad3b1c65d31f50d1800" id="r_aacd1dfd77f1b9ad3b1c65d31f50d1800"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacd1dfd77f1b9ad3b1c65d31f50d1800">printXLURES</a> (<a class="el" href="struct_s_s_t.html">SST</a> *sst, DWORD i)</td></tr>
<tr class="memdesc:aacd1dfd77f1b9ad3b1c65d31f50d1800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Печатает строку <a class="el" href="struct_x_l_u_r_e_s.html" title="Представляет строку в формате BIFF (Binary Interchange File Format) Excel.">XLURES</a> из таблицы <a class="el" href="struct_s_s_t.html" title="Структура, представляющая таблицу строк (String Table) в формате BIFF (Binary Interchange File Format...">SST</a>.  <br /></td></tr>
<tr class="separator:aacd1dfd77f1b9ad3b1c65d31f50d1800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66f6b31b5ad750f1fe042a706a4e3d4" id="r_ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> ()</td></tr>
<tr class="separator:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9f1433e87475b32499d3375087cffbd1" name="a9f1433e87475b32499d3375087cffbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1433e87475b32499d3375087cffbd1">&#9670;&#160;</a></span>checkSig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void checkSig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_f_header.html">CFHeader</a> *</td>          <td class="paramname"><span class="paramname"><em>cfh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Проверяет подпись заголовка файла для подтверждения формата Compound File. </p>
<p>Функция проверяет, соответствует ли подпись заголовка переданного объекта <code><a class="el" href="struct_c_f_header.html" title="Представляет заголовок Compound File (CF), используемый в формате Compound File Binary Format (CFBF).">CFHeader</a></code> заранее известной подписи для формата Compound File. Если подпись неверная, программа завершится с ошибкой. Если подпись верная, выводится сообщение о подтверждении формата.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfh</td><td>Указатель на структуру <a class="el" href="struct_c_f_header.html" title="Представляет заголовок Compound File (CF), используемый в формате Compound File Binary Format (CFBF).">CFHeader</a>, содержащую подпись заголовка файла.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Нет возвращаемого значения. В случае ошибки программа завершится. <div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="#a9f1433e87475b32499d3375087cffbd1">checkSig</a>(<a class="code hl_struct" href="struct_c_f_header.html">CFHeader</a>* cfh) {</div>
<div class="line">   BYTE trueHeaderSig[] = { 0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1 };</div>
<div class="line">   <span class="keywordflow">if</span> (!<a class="code hl_function" href="#a1f60f20a364269797af8f667e0e0d3dd">isEqualArr</a>(trueHeaderSig, cfh-&gt;<a class="code hl_variable" href="struct_c_f_header.html#ab63591e92494a4633ff392e51abfc2ef">Siganture</a>, 8)) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;File isn&#39;t a Compound File!&quot;</span> &lt;&lt; endl;;</div>
<div class="line">    exit(1);</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">else</span> {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Compound file confirmed!&quot;</span> &lt;&lt; endl;</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="ttc" id="a_x_l_s_parser_8cpp_html_a1f60f20a364269797af8f667e0e0d3dd"><div class="ttname"><a href="#a1f60f20a364269797af8f667e0e0d3dd">isEqualArr</a></div><div class="ttdeci">bool isEqualArr(BYTE *arr1, BYTE *arr2, DWORD size)</div><div class="ttdoc">Сравнивает два массива байтов на равенство.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00187">XLSParser.cpp:187</a></div></div>
<div class="ttc" id="a_x_l_s_parser_8cpp_html_a9f1433e87475b32499d3375087cffbd1"><div class="ttname"><a href="#a9f1433e87475b32499d3375087cffbd1">checkSig</a></div><div class="ttdeci">void checkSig(CFHeader *cfh)</div><div class="ttdoc">Проверяет подпись заголовка файла для подтверждения формата Compound File.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00482">XLSParser.cpp:482</a></div></div>
<div class="ttc" id="astruct_c_f_header_html"><div class="ttname"><a href="struct_c_f_header.html">CFHeader</a></div><div class="ttdoc">Представляет заголовок Compound File (CF), используемый в формате Compound File Binary Format (CFBF).</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00019">XLSParser.cpp:19</a></div></div>
<div class="ttc" id="astruct_c_f_header_html_ab63591e92494a4633ff392e51abfc2ef"><div class="ttname"><a href="struct_c_f_header.html#ab63591e92494a4633ff392e51abfc2ef">CFHeader::Siganture</a></div><div class="ttdeci">BYTE Siganture[8]</div><div class="ttdoc">Сигнатура файла, используемая для идентификации его формата.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00020">XLSParser.cpp:20</a></div></div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_x_l_s_parser_8cpp_source.html#l00482">482</a> of file <a class="el" href="_x_l_s_parser_8cpp_source.html">XLSParser.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_a9f1433e87475b32499d3375087cffbd1_cgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_a9f1433e87475b32499d3375087cffbd1_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_a9f1433e87475b32499d3375087cffbd1_icgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_a9f1433e87475b32499d3375087cffbd1_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a2b0ff8adaff08621b6eac375c9262e18" name="a2b0ff8adaff08621b6eac375c9262e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0ff8adaff08621b6eac375c9262e18">&#9670;&#160;</a></span>countDESectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DWORD countDESectors </td>
          <td>(</td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>fstDELoc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>fatCh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>secSize</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Подсчитывает количество секторов, связанных с цепочкой Directory Entry (DE). </p>
<p>Функция вычисляет количество секторов в цепочке DE, начиная с указанного первого сектора. Она использует FAT для поиска следующего сектора в цепочке, пока не встретит специальный маркер конца цепочки (0xFFFFFFFE).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fstDELoc</td><td>Номер первого сектора в цепочке Directory Entry. </td></tr>
    <tr><td class="paramname">buf</td><td>Указатель на буфер с данными файла. </td></tr>
    <tr><td class="paramname">fatCh</td><td>Указатель на массив с номерами секторов FAT. </td></tr>
    <tr><td class="paramname">secSize</td><td>Размер сектора в байтах.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Количество секторов в цепочке Directory Entry. <div class="fragment"><div class="line">DWORD <a class="code hl_function" href="#a2b0ff8adaff08621b6eac375c9262e18">countDESectors</a>(DWORD fstDELoc, BYTE* buf, DWORD* fatCh, DWORD secSize) {</div>
<div class="line">   DWORD k = 1;</div>
<div class="line">   DWORD i = fstDELoc;</div>
<div class="line">   <span class="keywordflow">while</span> (1) {</div>
<div class="line">    DWORD curFATSecIndex = i / (secSize / 4);</div>
<div class="line">    DWORD* fat = <span class="keyword">new</span> DWORD[secSize / 4];</div>
<div class="line">    <a class="code hl_function" href="#ac462abe109e1ef9562149cb5362f87b5">ReadSector</a>(fat, buf, fatCh[curFATSecIndex], secSize);</div>
<div class="line">    <span class="keywordflow">if</span> (fat[i % (secSize / 4)] == 0xfffffffe) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    i = fat[i % (secSize / 4)];</div>
<div class="line">    k++;</div>
<div class="line">    <span class="keyword">delete</span>[] fat;</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">return</span> k;</div>
<div class="line">}</div>
<div class="ttc" id="a_x_l_s_parser_8cpp_html_a2b0ff8adaff08621b6eac375c9262e18"><div class="ttname"><a href="#a2b0ff8adaff08621b6eac375c9262e18">countDESectors</a></div><div class="ttdeci">DWORD countDESectors(DWORD fstDELoc, BYTE *buf, DWORD *fatCh, DWORD secSize)</div><div class="ttdoc">Подсчитывает количество секторов, связанных с цепочкой Directory Entry (DE).</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00525">XLSParser.cpp:525</a></div></div>
<div class="ttc" id="a_x_l_s_parser_8cpp_html_ac462abe109e1ef9562149cb5362f87b5"><div class="ttname"><a href="#ac462abe109e1ef9562149cb5362f87b5">ReadSector</a></div><div class="ttdeci">void ReadSector(void *dst, BYTE *buf, DWORD secNum, DWORD size)</div><div class="ttdoc">Читает данные сектора из буфера в указанную область памяти.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00215">XLSParser.cpp:215</a></div></div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_x_l_s_parser_8cpp_source.html#l00525">525</a> of file <a class="el" href="_x_l_s_parser_8cpp_source.html">XLSParser.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_a2b0ff8adaff08621b6eac375c9262e18_cgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_a2b0ff8adaff08621b6eac375c9262e18_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_a2b0ff8adaff08621b6eac375c9262e18_icgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_a2b0ff8adaff08621b6eac375c9262e18_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a663eab00af52c5789387bddc85355eef" name="a663eab00af52c5789387bddc85355eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663eab00af52c5789387bddc85355eef">&#9670;&#160;</a></span>getbs8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="struct_bound_sheet8.html">BoundSheet8</a> &gt; getbs8 </td>
          <td>(</td>
          <td class="paramtype">BYTE *</td>          <td class="paramname"><span class="paramname"><em>Workbook</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>wbSSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>secSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>outOffset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Извлекает массив объектов <a class="el" href="struct_bound_sheet8.html" title="Структура для представления метаданных о листе в файле Excel.">BoundSheet8</a> из данных Workbook. </p>
<p>Функция парсит содержимое Workbook и извлекает записи типа <a class="el" href="struct_bound_sheet8.html" title="Структура для представления метаданных о листе в файле Excel.">BoundSheet8</a>, которые описывают листы электронной таблицы. Она возвращает вектор с объектами <a class="el" href="struct_bound_sheet8.html" title="Структура для представления метаданных о листе в файле Excel.">BoundSheet8</a> и смещение, на котором остановился парсер.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Workbook</td><td>Указатель на буфер данных Workbook. </td></tr>
    <tr><td class="paramname">wbSSize</td><td>Размер Workbook в секторах. </td></tr>
    <tr><td class="paramname">secSize</td><td>Размер сектора в байтах. </td></tr>
    <tr><td class="paramname">outOffset</td><td>Указатель на переменную, в которую будет записано итоговое смещение парсинга.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Вектор объектов <a class="el" href="struct_bound_sheet8.html" title="Структура для представления метаданных о листе в файле Excel.">BoundSheet8</a>, содержащих информацию о листах. <div class="fragment"><div class="line">vector&lt;BoundSheet8&gt; <a class="code hl_function" href="#a663eab00af52c5789387bddc85355eef">getbs8</a>(BYTE* Workbook, DWORD wbSSize, DWORD secSize, DWORD* outOffset) {</div>
<div class="line">   vector&lt;BoundSheet8&gt; bs8;</div>
<div class="line">   DWORD offset = 0;</div>
<div class="line">   <span class="keywordtype">bool</span> f = <span class="keyword">false</span>;</div>
<div class="line">   <span class="keywordflow">while</span> (offset &lt; wbSSize * secSize) {</div>
<div class="line">    <a class="code hl_struct" href="struct_record_head.html">RecordHead</a> rh;</div>
<div class="line">    <a class="code hl_struct" href="struct_bound_sheet8.html">BoundSheet8</a> bs;</div>
<div class="line">    memcpy(&amp;rh, &amp;Workbook[offset], 4);</div>
<div class="line">    <span class="keywordflow">if</span> (rh.<a class="code hl_variable" href="struct_record_head.html#a8898333ff19670cbde8eba6e11229c15">type</a> == 133 and f) {</div>
<div class="line">        offset += 4;</div>
<div class="line">        memcpy(&amp;bs, &amp;Workbook[offset], 8);</div>
<div class="line">        offset += 8;</div>
<div class="line">        bs.<a class="code hl_variable" href="struct_bound_sheet8.html#a593ff2a0db8d32f495940cb260b1f4a1">name</a>.<a class="code hl_variable" href="struct_s_x_l_u_s.html#a740d16c61f0c52052fd36b571d924914">rgb</a>.insert(bs.<a class="code hl_variable" href="struct_bound_sheet8.html#a593ff2a0db8d32f495940cb260b1f4a1">name</a>.<a class="code hl_variable" href="struct_s_x_l_u_s.html#a740d16c61f0c52052fd36b571d924914">rgb</a>.end(), &amp;Workbook[offset], &amp;Workbook[offset + rh.<a class="code hl_variable" href="struct_record_head.html#ac7d4b8ca80099018403728b8a0283ef0">size</a> - 8]);</div>
<div class="line">        bs8.push_back(bs);</div>
<div class="line">        offset += rh.<a class="code hl_variable" href="struct_record_head.html#ac7d4b8ca80099018403728b8a0283ef0">size</a> - 8;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rh.<a class="code hl_variable" href="struct_record_head.html#a8898333ff19670cbde8eba6e11229c15">type</a> == 133 and !f) {</div>
<div class="line">        f = <span class="keyword">true</span>;</div>
<div class="line">        offset += 4;</div>
<div class="line">        memcpy(&amp;bs, &amp;Workbook[offset], 8);</div>
<div class="line">        offset += 8;</div>
<div class="line">        bs.<a class="code hl_variable" href="struct_bound_sheet8.html#a593ff2a0db8d32f495940cb260b1f4a1">name</a>.<a class="code hl_variable" href="struct_s_x_l_u_s.html#a740d16c61f0c52052fd36b571d924914">rgb</a>.insert(bs.<a class="code hl_variable" href="struct_bound_sheet8.html#a593ff2a0db8d32f495940cb260b1f4a1">name</a>.<a class="code hl_variable" href="struct_s_x_l_u_s.html#a740d16c61f0c52052fd36b571d924914">rgb</a>.end(), &amp;Workbook[offset], &amp;Workbook[offset + rh.<a class="code hl_variable" href="struct_record_head.html#ac7d4b8ca80099018403728b8a0283ef0">size</a> - 8]);</div>
<div class="line">        bs8.push_back(bs);</div>
<div class="line">        offset += rh.<a class="code hl_variable" href="struct_record_head.html#ac7d4b8ca80099018403728b8a0283ef0">size</a> - 8;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rh.<a class="code hl_variable" href="struct_record_head.html#a8898333ff19670cbde8eba6e11229c15">type</a> != 133 and f) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        offset += 4 + rh.<a class="code hl_variable" href="struct_record_head.html#ac7d4b8ca80099018403728b8a0283ef0">size</a>;</div>
<div class="line">    }</div>
<div class="line">   }</div>
<div class="line">    *outOffset = offset;</div>
<div class="line">   <span class="keywordflow">return</span> bs8;</div>
<div class="line">}</div>
<div class="ttc" id="a_x_l_s_parser_8cpp_html_a663eab00af52c5789387bddc85355eef"><div class="ttname"><a href="#a663eab00af52c5789387bddc85355eef">getbs8</a></div><div class="ttdeci">vector&lt; BoundSheet8 &gt; getbs8(BYTE *Workbook, DWORD wbSSize, DWORD secSize, DWORD *outOffset)</div><div class="ttdoc">Извлекает массив объектов BoundSheet8 из данных Workbook.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00732">XLSParser.cpp:732</a></div></div>
<div class="ttc" id="astruct_bound_sheet8_html"><div class="ttname"><a href="struct_bound_sheet8.html">BoundSheet8</a></div><div class="ttdoc">Структура для представления метаданных о листе в файле Excel.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00121">XLSParser.cpp:121</a></div></div>
<div class="ttc" id="astruct_bound_sheet8_html_a593ff2a0db8d32f495940cb260b1f4a1"><div class="ttname"><a href="struct_bound_sheet8.html#a593ff2a0db8d32f495940cb260b1f4a1">BoundSheet8::name</a></div><div class="ttdeci">SXLUS name</div><div class="ttdoc">Имя листа.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00125">XLSParser.cpp:125</a></div></div>
<div class="ttc" id="astruct_record_head_html"><div class="ttname"><a href="struct_record_head.html">RecordHead</a></div><div class="ttdoc">Заголовок записи в структуре данных документа Compound File Binary Format (CFBF).</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00071">XLSParser.cpp:71</a></div></div>
<div class="ttc" id="astruct_record_head_html_a8898333ff19670cbde8eba6e11229c15"><div class="ttname"><a href="struct_record_head.html#a8898333ff19670cbde8eba6e11229c15">RecordHead::type</a></div><div class="ttdeci">WORD type</div><div class="ttdoc">Тип записи.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00072">XLSParser.cpp:72</a></div></div>
<div class="ttc" id="astruct_record_head_html_ac7d4b8ca80099018403728b8a0283ef0"><div class="ttname"><a href="struct_record_head.html#ac7d4b8ca80099018403728b8a0283ef0">RecordHead::size</a></div><div class="ttdeci">WORD size</div><div class="ttdoc">Размер записи</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00073">XLSParser.cpp:73</a></div></div>
<div class="ttc" id="astruct_s_x_l_u_s_html_a740d16c61f0c52052fd36b571d924914"><div class="ttname"><a href="struct_s_x_l_u_s.html#a740d16c61f0c52052fd36b571d924914">SXLUS::rgb</a></div><div class="ttdeci">vector&lt; BYTE &gt; rgb</div><div class="ttdoc">Вектор байтов, представляющий строку в кодировке, зависящей от значения fHighByte.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00111">XLSParser.cpp:111</a></div></div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_x_l_s_parser_8cpp_source.html#l00732">732</a> of file <a class="el" href="_x_l_s_parser_8cpp_source.html">XLSParser.cpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_a663eab00af52c5789387bddc85355eef_icgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_a663eab00af52c5789387bddc85355eef_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a2135890fef23bcc112b0a236b9b6c20c" name="a2135890fef23bcc112b0a236b9b6c20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2135890fef23bcc112b0a236b9b6c20c">&#9670;&#160;</a></span>getData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE * getData </td>
          <td>(</td>
          <td class="paramtype">HANDLE</td>          <td class="paramname"><span class="paramname"><em>fileHandle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Читает данные из файла в буфер. </p>
<p>Функция читает всё содержимое указанного файла в динамически выделенный буфер и возвращает указатель на этот буфер. Если чтение файла завершается с ошибкой, выводится сообщение об ошибке, и программа завершает выполнение.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileHandle</td><td>Дескриптор открытого файла, из которого нужно считать данные.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Возвращает указатель на буфер с прочитанными данными из файла. <div class="fragment"><div class="line">BYTE* <a class="code hl_function" href="#a2135890fef23bcc112b0a236b9b6c20c">getData</a>(HANDLE fileHandle) {</div>
<div class="line">   DWORD fileSize = GetFileSize(fileHandle, NULL);</div>
<div class="line">   DWORD bytesRead;</div>
<div class="line">   BYTE* buf = <span class="keyword">new</span> BYTE[fileSize];</div>
<div class="line">   BOOL readOK = ReadFile(fileHandle, buf, fileSize, &amp;bytesRead, NULL);</div>
<div class="line">   <span class="keywordflow">if</span> (!readOK) {</div>
<div class="line">    wcout &lt;&lt; L<span class="stringliteral">&quot;Ошибка чтения файла!&quot;</span> &lt;&lt; endl;</div>
<div class="line">    CloseHandle(fileHandle);</div>
<div class="line">    exit(1);</div>
<div class="line">   }</div>
<div class="line">   CloseHandle(fileHandle);</div>
<div class="line">   <span class="keywordflow">return</span> buf;</div>
<div class="line">}</div>
<div class="ttc" id="a_x_l_s_parser_8cpp_html_a2135890fef23bcc112b0a236b9b6c20c"><div class="ttname"><a href="#a2135890fef23bcc112b0a236b9b6c20c">getData</a></div><div class="ttdeci">BYTE * getData(HANDLE fileHandle)</div><div class="ttdoc">Читает данные из файла в буфер.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00420">XLSParser.cpp:420</a></div></div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_x_l_s_parser_8cpp_source.html#l00420">420</a> of file <a class="el" href="_x_l_s_parser_8cpp_source.html">XLSParser.cpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_a2135890fef23bcc112b0a236b9b6c20c_icgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_a2135890fef23bcc112b0a236b9b6c20c_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ab77afacbaeb29cd296eb5dd6f3f64e00" name="ab77afacbaeb29cd296eb5dd6f3f64e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77afacbaeb29cd296eb5dd6f3f64e00">&#9670;&#160;</a></span>getDEChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DWORD * getDEChain </td>
          <td>(</td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>fstDELoc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>fatCh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>secSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Создает цепочку секторов Directory Entry (DE) из FAT. </p>
<p>Эта функция формирует массив секторов, представляющий цепочку Directory Entry (DE), начиная с указанного начального сектора. Память под массив выделяется динамически, и её необходимо освободить с помощью <code>delete[]</code> после использования.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fstDELoc</td><td>Номер начального сектора в цепочке Directory Entry. </td></tr>
    <tr><td class="paramname">buf</td><td>Указатель на буфер с данными Compound File. </td></tr>
    <tr><td class="paramname">fatCh</td><td>Указатель на массив секторов FAT, определяющий структуру цепочек. </td></tr>
    <tr><td class="paramname">secSize</td><td>Размер сектора в байтах. </td></tr>
    <tr><td class="paramname">k</td><td>Количество секторов в цепочке Directory Entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Указатель на массив номеров секторов цепочки Directory Entry. <div class="fragment"><div class="line">DWORD* <a class="code hl_function" href="#ab77afacbaeb29cd296eb5dd6f3f64e00">getDEChain</a>(DWORD fstDELoc, BYTE* buf, DWORD* fatCh, DWORD secSize, DWORD k) {</div>
<div class="line">   DWORD* deChain = <span class="keyword">new</span> DWORD[k];</div>
<div class="line">   deChain[0] = fstDELoc;</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; k; i++) {</div>
<div class="line">    DWORD curFATSecIndex = deChain[i - 1] / (secSize / 4);</div>
<div class="line">    DWORD* fat = <span class="keyword">new</span> DWORD[secSize / 4];</div>
<div class="line">    <a class="code hl_function" href="#ac462abe109e1ef9562149cb5362f87b5">ReadSector</a>(fat, buf, fatCh[curFATSecIndex], secSize);</div>
<div class="line">    deChain[i] = fat[deChain[i - 1] % (secSize / 4)];</div>
<div class="line">    <span class="keyword">delete</span>[] fat;</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">return</span> deChain;</div>
<div class="line">}</div>
<div class="ttc" id="a_x_l_s_parser_8cpp_html_ab77afacbaeb29cd296eb5dd6f3f64e00"><div class="ttname"><a href="#ab77afacbaeb29cd296eb5dd6f3f64e00">getDEChain</a></div><div class="ttdeci">DWORD * getDEChain(DWORD fstDELoc, BYTE *buf, DWORD *fatCh, DWORD secSize, DWORD k)</div><div class="ttdoc">Создает цепочку секторов Directory Entry (DE) из FAT.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00571">XLSParser.cpp:571</a></div></div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_x_l_s_parser_8cpp_source.html#l00571">571</a> of file <a class="el" href="_x_l_s_parser_8cpp_source.html">XLSParser.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_ab77afacbaeb29cd296eb5dd6f3f64e00_cgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_ab77afacbaeb29cd296eb5dd6f3f64e00_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_ab77afacbaeb29cd296eb5dd6f3f64e00_icgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_ab77afacbaeb29cd296eb5dd6f3f64e00_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="aec0b8d48ed8464d0e2208e4e35583a0d" name="aec0b8d48ed8464d0e2208e4e35583a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0b8d48ed8464d0e2208e4e35583a0d">&#9670;&#160;</a></span>getDIFATChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getDIFATChain </td>
          <td>(</td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_f_header.html">CFHeader</a> *</td>          <td class="paramname"><span class="paramname"><em>cfh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>secSize</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Извлекает цепочку DIFAT секторов и сохраняет их в массив. </p>
<p>Функция извлекает цепочку секторов DIFAT (FAT для больших файлов) и сохраняет их в указанный массив.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Указатель на массив, в который будут записаны номера секторов DIFAT. </td></tr>
    <tr><td class="paramname">cfh</td><td>Указатель на структуру заголовка CF (Compound File), которая содержит информацию о секторах DIFAT. </td></tr>
    <tr><td class="paramname">buf</td><td>Указатель на буфер, содержащий все данные файловой системы. </td></tr>
    <tr><td class="paramname">secSize</td><td>Размер сектора в байтах. <div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="#aec0b8d48ed8464d0e2208e4e35583a0d">getDIFATChain</a>(DWORD* dst, <a class="code hl_struct" href="struct_c_f_header.html">CFHeader</a>* cfh, BYTE* buf, DWORD secSize) {</div>
<div class="line">   dst[0] = cfh-&gt;<a class="code hl_variable" href="struct_c_f_header.html#aba010975e4e098a50381dfb0cf026d49">firstDIFATSecLoc</a>;</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; cfh-&gt;<a class="code hl_variable" href="struct_c_f_header.html#acd546ee00b7452f4307c9c6ea9667a0b">numOfDIFATSectors</a>; i++) {</div>
<div class="line">    DWORD next;</div>
<div class="line">    memcpy(&amp;next, &amp;buf[dst[i - 1] * (secSize + 1) + secSize - 4], 4);</div>
<div class="line">        <span class="keywordflow">if</span> (next == 0xfffffffe) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    dst[i] = next;</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="ttc" id="a_x_l_s_parser_8cpp_html_aec0b8d48ed8464d0e2208e4e35583a0d"><div class="ttname"><a href="#aec0b8d48ed8464d0e2208e4e35583a0d">getDIFATChain</a></div><div class="ttdeci">void getDIFATChain(DWORD *dst, CFHeader *cfh, BYTE *buf, DWORD secSize)</div><div class="ttdoc">Извлекает цепочку DIFAT секторов и сохраняет их в массив.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00243">XLSParser.cpp:243</a></div></div>
<div class="ttc" id="astruct_c_f_header_html_aba010975e4e098a50381dfb0cf026d49"><div class="ttname"><a href="struct_c_f_header.html#aba010975e4e098a50381dfb0cf026d49">CFHeader::firstDIFATSecLoc</a></div><div class="ttdeci">DWORD firstDIFATSecLoc</div><div class="ttdoc">Первый сектор DIFAT.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00035">XLSParser.cpp:35</a></div></div>
<div class="ttc" id="astruct_c_f_header_html_acd546ee00b7452f4307c9c6ea9667a0b"><div class="ttname"><a href="struct_c_f_header.html#acd546ee00b7452f4307c9c6ea9667a0b">CFHeader::numOfDIFATSectors</a></div><div class="ttdeci">DWORD numOfDIFATSectors</div><div class="ttdoc">Количество DIFAT-секторов.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00036">XLSParser.cpp:36</a></div></div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_x_l_s_parser_8cpp_source.html#l00243">243</a> of file <a class="el" href="_x_l_s_parser_8cpp_source.html">XLSParser.cpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_aec0b8d48ed8464d0e2208e4e35583a0d_icgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_aec0b8d48ed8464d0e2208e4e35583a0d_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a72dbc33b77d2c5e83ddd6751866e3b7d" name="a72dbc33b77d2c5e83ddd6751866e3b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72dbc33b77d2c5e83ddd6751866e3b7d">&#9670;&#160;</a></span>getFATChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getFATChain </td>
          <td>(</td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>difCh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_f_header.html">CFHeader</a> *</td>          <td class="paramname"><span class="paramname"><em>cfh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>secSize</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Извлекает цепочку FAT секторов и сохраняет их в массив. </p>
<p>Функция извлекает цепочку секторов FAT, начиная с данных, которые содержатся в DIFAT (сектора для FAT), и сохраняет их в указанный массив.</p>
<p>Функция сначала копирует секторы FAT, указанные в структуре <code>cfh-&gt;DIFAT</code>, в массив <code>dst</code>. Если количество секторов FAT больше 109, то дополнительная информация о FAT считывается из секторов DIFAT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Указатель на массив, в который будут записаны номера секторов FAT. </td></tr>
    <tr><td class="paramname">difCh</td><td>Массив, содержащий номера секторов DIFAT. </td></tr>
    <tr><td class="paramname">cfh</td><td>Указатель на структуру заголовка CF (Compound File), содержащую информацию о секторах DIFAT и FAT. </td></tr>
    <tr><td class="paramname">buf</td><td>Указатель на буфер, содержащий все данные файловой системы. </td></tr>
    <tr><td class="paramname">secSize</td><td>Размер сектора в байтах. <div class="fragment"><div class="line"> <span class="keywordtype">void</span> <a class="code hl_function" href="#a72dbc33b77d2c5e83ddd6751866e3b7d">getFATChain</a>(DWORD* dst, DWORD* difCh, <a class="code hl_struct" href="struct_c_f_header.html">CFHeader</a>* cfh, BYTE* buf, DWORD secSize) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 109; i++) {</div>
<div class="line">        <span class="keywordflow">if</span> (cfh-&gt;<a class="code hl_variable" href="struct_c_f_header.html#a92bd75cd389ecf7055f0727d04746d66">DIFAT</a>[i] == 0xffffffff) {</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        dst[i] = cfh-&gt;<a class="code hl_variable" href="struct_c_f_header.html#a92bd75cd389ecf7055f0727d04746d66">DIFAT</a>[i];</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (cfh-&gt;<a class="code hl_variable" href="struct_c_f_header.html#a8692e9bf989b689387c5a21b4121c4c0">numOfFATSectors</a> &gt; 109) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; cfh-&gt;<a class="code hl_variable" href="struct_c_f_header.html#acd546ee00b7452f4307c9c6ea9667a0b">numOfDIFATSectors</a>; i++) {</div>
<div class="line">            DWORD* difat = <span class="keyword">new</span> DWORD[secSize / 4];</div>
<div class="line">            <a class="code hl_function" href="#ac462abe109e1ef9562149cb5362f87b5">ReadSector</a>(difat, buf, difCh[i], secSize);</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; (secSize / 4) - 1; j++) {</div>
<div class="line">                <span class="keywordflow">if</span> (difat[j] == 0xffffffff) {</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">                dst[109 + (i * secSize) + j] = difat[j];</div>
<div class="line">            }</div>
<div class="line">            <span class="keyword">delete</span>[] difat;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="a_x_l_s_parser_8cpp_html_a72dbc33b77d2c5e83ddd6751866e3b7d"><div class="ttname"><a href="#a72dbc33b77d2c5e83ddd6751866e3b7d">getFATChain</a></div><div class="ttdeci">void getFATChain(DWORD *dst, DWORD *difCh, CFHeader *cfh, BYTE *buf, DWORD secSize)</div><div class="ttdoc">Извлекает цепочку FAT секторов и сохраняет их в массив.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00294">XLSParser.cpp:294</a></div></div>
<div class="ttc" id="astruct_c_f_header_html_a8692e9bf989b689387c5a21b4121c4c0"><div class="ttname"><a href="struct_c_f_header.html#a8692e9bf989b689387c5a21b4121c4c0">CFHeader::numOfFATSectors</a></div><div class="ttdeci">DWORD numOfFATSectors</div><div class="ttdoc">Количество FAT-секторов.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00029">XLSParser.cpp:29</a></div></div>
<div class="ttc" id="astruct_c_f_header_html_a92bd75cd389ecf7055f0727d04746d66"><div class="ttname"><a href="struct_c_f_header.html#a92bd75cd389ecf7055f0727d04746d66">CFHeader::DIFAT</a></div><div class="ttdeci">DWORD DIFAT[109]</div><div class="ttdoc">DIFAT-таблица.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00037">XLSParser.cpp:37</a></div></div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_x_l_s_parser_8cpp_source.html#l00294">294</a> of file <a class="el" href="_x_l_s_parser_8cpp_source.html">XLSParser.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_a72dbc33b77d2c5e83ddd6751866e3b7d_cgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_a72dbc33b77d2c5e83ddd6751866e3b7d_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_a72dbc33b77d2c5e83ddd6751866e3b7d_icgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_a72dbc33b77d2c5e83ddd6751866e3b7d_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a68ef7395b571ecce29fba836ff37a909" name="a68ef7395b571ecce29fba836ff37a909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ef7395b571ecce29fba836ff37a909">&#9670;&#160;</a></span>getSST()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_s_t.html">SST</a> * getSST </td>
          <td>(</td>
          <td class="paramtype">BYTE *</td>          <td class="paramname"><span class="paramname"><em>Workbook</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>wbSSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>secSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Извлекает таблицу общих строк (Shared String Table, <a class="el" href="struct_s_s_t.html" title="Структура, представляющая таблицу строк (String Table) в формате BIFF (Binary Interchange File Format...">SST</a>) из Workbook. </p>
<p>Функция считывает структуру <a class="el" href="struct_s_s_t.html" title="Структура, представляющая таблицу строк (String Table) в формате BIFF (Binary Interchange File Format...">SST</a> из потока Workbook, включая строки с расширенными свойствами. <a class="el" href="struct_s_s_t.html" title="Структура, представляющая таблицу строк (String Table) в формате BIFF (Binary Interchange File Format...">SST</a> используется для хранения строковых данных, которые используются в ячейках листов Excel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Workbook</td><td>Указатель на массив байтов, представляющий содержимое Workbook. </td></tr>
    <tr><td class="paramname">wbSSize</td><td>Количество секторов в Workbook. </td></tr>
    <tr><td class="paramname">secSize</td><td>Размер одного сектора в байтах. </td></tr>
    <tr><td class="paramname">offset</td><td>Смещение, с которого начинается поиск <a class="el" href="struct_s_s_t.html" title="Структура, представляющая таблицу строк (String Table) в формате BIFF (Binary Interchange File Format...">SST</a> в Workbook. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Указатель на структуру <a class="el" href="struct_s_s_t.html" title="Структура, представляющая таблицу строк (String Table) в формате BIFF (Binary Interchange File Format...">SST</a>, содержащую строки из таблицы общих строк. <div class="fragment"><div class="line"><a class="code hl_struct" href="struct_s_s_t.html">SST</a>* <a class="code hl_function" href="#a68ef7395b571ecce29fba836ff37a909">getSST</a>(BYTE* Workbook, DWORD wbSSize, DWORD secSize, DWORD offset) {</div>
<div class="line">   <a class="code hl_struct" href="struct_s_s_t.html">SST</a>* sst = <span class="keyword">new</span> <a class="code hl_struct" href="struct_s_s_t.html">SST</a>;</div>
<div class="line">   <a class="code hl_struct" href="struct_record_head.html">RecordHead</a> rh;</div>
<div class="line">   <span class="keywordflow">while</span> (offset &lt; wbSSize * secSize) {</div>
<div class="line">    memcpy(&amp;rh, &amp;Workbook[offset], 4);</div>
<div class="line">    <span class="keywordflow">if</span> (rh.<a class="code hl_variable" href="struct_record_head.html#a8898333ff19670cbde8eba6e11229c15">type</a> == 252) {</div>
<div class="line">        offset += 4;</div>
<div class="line">        memcpy(sst, &amp;Workbook[offset], 8);</div>
<div class="line">        offset += 8;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        offset += 4 + rh.<a class="code hl_variable" href="struct_record_head.html#ac7d4b8ca80099018403728b8a0283ef0">size</a>;</div>
<div class="line">    }</div>
<div class="line">   }</div>
<div class="line">   DWORD sstEnd = offset + rh.<a class="code hl_variable" href="struct_record_head.html#ac7d4b8ca80099018403728b8a0283ef0">size</a> - 8;</div>
<div class="line">   <span class="keywordflow">while</span> (offset &lt; sstEnd) {</div>
<div class="line">    <a class="code hl_struct" href="struct_x_l_u_r_e_s.html">XLURES</a> str;</div>
<div class="line">    memcpy(&amp;str, &amp;Workbook[offset], 3);</div>
<div class="line">    offset += 3;</div>
<div class="line">    <span class="keywordflow">if</span> (str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a71f3b30ccd3b3f42cc28c066cbdc814e">fRichSt</a> == 1) {</div>
<div class="line">        memcpy(&amp;(str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a97a884db209aa171e47bc1011184ef0b">cRun</a>), &amp;Workbook[offset], 2);</div>
<div class="line">        offset += 2;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a997b551a80add5a48b2b67921a4a7644">fExtSt</a> == 1) {</div>
<div class="line">        memcpy(&amp;(str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a6ce7720fe581a36dd2674ef0ea0ee1fa">cbExtRst</a>), &amp;Workbook[offset], 4);</div>
<div class="line">        offset += 4;</div>
<div class="line">    }</div>
<div class="line">    DWORD strEnd = offset + str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#affb254823ba2974e33e6538e5a3919a0">cch</a> * (str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a2aef779a1eb92333dfc17816ff9ec4d7">fHighByte</a> + 1);</div>
<div class="line">    <span class="keywordflow">if</span> (strEnd &gt; sstEnd) {</div>
<div class="line">        strEnd = sstEnd;</div>
<div class="line">    }</div>
<div class="line">    str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a13abc96352f1a4f7f5be0fda9429d0c5">rgb</a>.insert(str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a13abc96352f1a4f7f5be0fda9429d0c5">rgb</a>.end(), &amp;Workbook[offset], &amp;Workbook[strEnd]);</div>
<div class="line">    offset = strEnd + str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a97a884db209aa171e47bc1011184ef0b">cRun</a> * 4 + str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a6ce7720fe581a36dd2674ef0ea0ee1fa">cbExtRst</a>;</div>
<div class="line">    sst-&gt;<a class="code hl_variable" href="struct_s_s_t.html#a18e2f91f34feefe5f02c5c0be159c9de">strings</a>.push_back(str);</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">if</span> (rh.<a class="code hl_variable" href="struct_record_head.html#ac7d4b8ca80099018403728b8a0283ef0">size</a> == 8224) {</div>
<div class="line">    <span class="keywordflow">while</span> (offset &lt; wbSSize * secSize) {</div>
<div class="line">        memcpy(&amp;rh, &amp;Workbook[offset], 4);</div>
<div class="line">        <span class="keywordflow">if</span> (rh.<a class="code hl_variable" href="struct_record_head.html#a8898333ff19670cbde8eba6e11229c15">type</a> == 60) {</div>
<div class="line">            offset += 4;</div>
<div class="line">            DWORD conOffset = offset;</div>
<div class="line">            <span class="keywordflow">if</span> (sst-&gt;<a class="code hl_variable" href="struct_s_s_t.html#a18e2f91f34feefe5f02c5c0be159c9de">strings</a>.back().rgb.size() &lt; (sst-&gt;<a class="code hl_variable" href="struct_s_s_t.html#a18e2f91f34feefe5f02c5c0be159c9de">strings</a>.back().cch * (sst-&gt;<a class="code hl_variable" href="struct_s_s_t.html#a18e2f91f34feefe5f02c5c0be159c9de">strings</a>.back().fHighByte + 1))) {</div>
<div class="line">                DWORD strEnd = offset + 1 + sst-&gt;<a class="code hl_variable" href="struct_s_s_t.html#a18e2f91f34feefe5f02c5c0be159c9de">strings</a>.back().cch * (sst-&gt;<a class="code hl_variable" href="struct_s_s_t.html#a18e2f91f34feefe5f02c5c0be159c9de">strings</a>.back().fHighByte + 1) - sst-&gt;<a class="code hl_variable" href="struct_s_s_t.html#a18e2f91f34feefe5f02c5c0be159c9de">strings</a>.back().rgb.size();</div>
<div class="line">                sst-&gt;<a class="code hl_variable" href="struct_s_s_t.html#a18e2f91f34feefe5f02c5c0be159c9de">strings</a>.back().rgb.insert(sst-&gt;<a class="code hl_variable" href="struct_s_s_t.html#a18e2f91f34feefe5f02c5c0be159c9de">strings</a>.back().rgb.end(), &amp;Workbook[offset + 1], &amp;Workbook[strEnd]);</div>
<div class="line">                offset = strEnd + sst-&gt;<a class="code hl_variable" href="struct_s_s_t.html#a18e2f91f34feefe5f02c5c0be159c9de">strings</a>.back().cRun * 4 + sst-&gt;<a class="code hl_variable" href="struct_s_s_t.html#a18e2f91f34feefe5f02c5c0be159c9de">strings</a>.back().cbExtRst;</div>
<div class="line">            }</div>
<div class="line">            DWORD conEnd = conOffset + rh.<a class="code hl_variable" href="struct_record_head.html#ac7d4b8ca80099018403728b8a0283ef0">size</a>;</div>
<div class="line">            <span class="keywordflow">while</span> (offset &lt; conEnd) {</div>
<div class="line">                <a class="code hl_struct" href="struct_x_l_u_r_e_s.html">XLURES</a> str;</div>
<div class="line">                memcpy(&amp;str, &amp;Workbook[offset], 3);</div>
<div class="line">                offset += 3;</div>
<div class="line">                <span class="keywordflow">if</span> (str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a71f3b30ccd3b3f42cc28c066cbdc814e">fRichSt</a> == 1) {</div>
<div class="line">                    memcpy(&amp;(str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a97a884db209aa171e47bc1011184ef0b">cRun</a>), &amp;Workbook[offset], 2);</div>
<div class="line">                    offset += 2;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span> (str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a997b551a80add5a48b2b67921a4a7644">fExtSt</a> == 1) {</div>
<div class="line">                    memcpy(&amp;(str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a6ce7720fe581a36dd2674ef0ea0ee1fa">cbExtRst</a>), &amp;Workbook[offset], 4);</div>
<div class="line">                    offset += 4;</div>
<div class="line">                }</div>
<div class="line">                DWORD strEnd = offset + str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#affb254823ba2974e33e6538e5a3919a0">cch</a> * (str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a2aef779a1eb92333dfc17816ff9ec4d7">fHighByte</a> + 1);</div>
<div class="line">                <span class="keywordflow">if</span> (strEnd &gt; conEnd) {</div>
<div class="line">                    strEnd = conEnd;</div>
<div class="line">                }</div>
<div class="line">                str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a13abc96352f1a4f7f5be0fda9429d0c5">rgb</a>.insert(str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a13abc96352f1a4f7f5be0fda9429d0c5">rgb</a>.end(), &amp;Workbook[offset], &amp;Workbook[strEnd]);</div>
<div class="line">                offset = strEnd + str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a97a884db209aa171e47bc1011184ef0b">cRun</a> * 4 + str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a6ce7720fe581a36dd2674ef0ea0ee1fa">cbExtRst</a>;</div>
<div class="line">                sst-&gt;<a class="code hl_variable" href="struct_s_s_t.html#a18e2f91f34feefe5f02c5c0be159c9de">strings</a>.push_back(str);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">return</span> sst;</div>
<div class="line">}</div>
<div class="ttc" id="a_x_l_s_parser_8cpp_html_a68ef7395b571ecce29fba836ff37a909"><div class="ttname"><a href="#a68ef7395b571ecce29fba836ff37a909">getSST</a></div><div class="ttdeci">SST * getSST(BYTE *Workbook, DWORD wbSSize, DWORD secSize, DWORD offset)</div><div class="ttdoc">Извлекает таблицу общих строк (Shared String Table, SST) из Workbook.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00889">XLSParser.cpp:889</a></div></div>
<div class="ttc" id="astruct_s_s_t_html"><div class="ttname"><a href="struct_s_s_t.html">SST</a></div><div class="ttdoc">Структура, представляющая таблицу строк (String Table) в формате BIFF (Binary Interchange File Format...</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00155">XLSParser.cpp:155</a></div></div>
<div class="ttc" id="astruct_s_s_t_html_a18e2f91f34feefe5f02c5c0be159c9de"><div class="ttname"><a href="struct_s_s_t.html#a18e2f91f34feefe5f02c5c0be159c9de">SST::strings</a></div><div class="ttdeci">vector&lt; XLURES &gt; strings</div><div class="ttdoc">Вектор, содержащий уникальные строки таблицы.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00158">XLSParser.cpp:158</a></div></div>
<div class="ttc" id="astruct_x_l_u_r_e_s_html"><div class="ttname"><a href="struct_x_l_u_r_e_s.html">XLURES</a></div><div class="ttdoc">Представляет строку в формате BIFF (Binary Interchange File Format) Excel.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00135">XLSParser.cpp:135</a></div></div>
<div class="ttc" id="astruct_x_l_u_r_e_s_html_a13abc96352f1a4f7f5be0fda9429d0c5"><div class="ttname"><a href="struct_x_l_u_r_e_s.html#a13abc96352f1a4f7f5be0fda9429d0c5">XLURES::rgb</a></div><div class="ttdeci">vector&lt; BYTE &gt; rgb</div><div class="ttdoc">Содержимое строки.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00144">XLSParser.cpp:144</a></div></div>
<div class="ttc" id="astruct_x_l_u_r_e_s_html_a2aef779a1eb92333dfc17816ff9ec4d7"><div class="ttname"><a href="struct_x_l_u_r_e_s.html#a2aef779a1eb92333dfc17816ff9ec4d7">XLURES::fHighByte</a></div><div class="ttdeci">BYTE fHighByte</div><div class="ttdoc">Флаг, указывающий, содержит ли строка символы Unicode.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00137">XLSParser.cpp:137</a></div></div>
<div class="ttc" id="astruct_x_l_u_r_e_s_html_a6ce7720fe581a36dd2674ef0ea0ee1fa"><div class="ttname"><a href="struct_x_l_u_r_e_s.html#a6ce7720fe581a36dd2674ef0ea0ee1fa">XLURES::cbExtRst</a></div><div class="ttdeci">DWORD cbExtRst</div><div class="ttdoc">Размер расширенных данных строки (в байтах).</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00143">XLSParser.cpp:143</a></div></div>
<div class="ttc" id="astruct_x_l_u_r_e_s_html_a71f3b30ccd3b3f42cc28c066cbdc814e"><div class="ttname"><a href="struct_x_l_u_r_e_s.html#a71f3b30ccd3b3f42cc28c066cbdc814e">XLURES::fRichSt</a></div><div class="ttdeci">BYTE fRichSt</div><div class="ttdoc">Флаг наличия данных форматирования (rich text).</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00140">XLSParser.cpp:140</a></div></div>
<div class="ttc" id="astruct_x_l_u_r_e_s_html_a97a884db209aa171e47bc1011184ef0b"><div class="ttname"><a href="struct_x_l_u_r_e_s.html#a97a884db209aa171e47bc1011184ef0b">XLURES::cRun</a></div><div class="ttdeci">WORD cRun</div><div class="ttdoc">Количество пар форматирования rich text.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00142">XLSParser.cpp:142</a></div></div>
<div class="ttc" id="astruct_x_l_u_r_e_s_html_a997b551a80add5a48b2b67921a4a7644"><div class="ttname"><a href="struct_x_l_u_r_e_s.html#a997b551a80add5a48b2b67921a4a7644">XLURES::fExtSt</a></div><div class="ttdeci">BYTE fExtSt</div><div class="ttdoc">Флаг наличия расширенных данных строки.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00139">XLSParser.cpp:139</a></div></div>
<div class="ttc" id="astruct_x_l_u_r_e_s_html_affb254823ba2974e33e6538e5a3919a0"><div class="ttname"><a href="struct_x_l_u_r_e_s.html#affb254823ba2974e33e6538e5a3919a0">XLURES::cch</a></div><div class="ttdeci">WORD cch</div><div class="ttdoc">Количество символов в строке.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00136">XLSParser.cpp:136</a></div></div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_x_l_s_parser_8cpp_source.html#l00889">889</a> of file <a class="el" href="_x_l_s_parser_8cpp_source.html">XLSParser.cpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_a68ef7395b571ecce29fba836ff37a909_icgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_a68ef7395b571ecce29fba836ff37a909_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a3835c3169fc0f7dd1ef7f64c5273d877" name="a3835c3169fc0f7dd1ef7f64c5273d877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3835c3169fc0f7dd1ef7f64c5273d877">&#9670;&#160;</a></span>getWorkbookChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getWorkbookChain </td>
          <td>(</td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>fatCh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_directory_entry.html">DirectoryEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>de</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>chainSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>secSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Извлекает цепочку секторов книги из FAT и сохраняет их в массив. </p>
<p>Функция извлекает цепочку секторов рабочей книги, используя информацию из FAT, и сохраняет её в массив. Каждый сектор FAT указывает на следующий сектор в цепочке, и эта информация используется для восстановления последовательности секторов, содержащих данные книги.</p>
<p>Для каждой позиции в цепочке, функция рассчитывает, какой сектор FAT нужно использовать, и читает его, чтобы найти адрес следующего сектора. Этот процесс повторяется до тех пор, пока не будет извлечено нужное количество секторов.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Массив, в который будут записаны номера секторов рабочей книги. </td></tr>
    <tr><td class="paramname">fatCh</td><td>Массив с номерами секторов FAT. </td></tr>
    <tr><td class="paramname">de</td><td>Указатель на структуру <a class="el" href="struct_directory_entry.html" title="Представляет запись каталога в формате Compound File Binary Format (CFBF).">DirectoryEntry</a>, содержащую информацию о начале цепочки секторов. </td></tr>
    <tr><td class="paramname">chainSize</td><td>Размер цепочки секторов, которую нужно извлечь. </td></tr>
    <tr><td class="paramname">secSize</td><td>Размер сектора в байтах. </td></tr>
    <tr><td class="paramname">buf</td><td>Указатель на буфер, содержащий все данные файловой системы. <div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="#a3835c3169fc0f7dd1ef7f64c5273d877">getWorkbookChain</a>(DWORD* dst, DWORD* fatCh, <a class="code hl_struct" href="struct_directory_entry.html">DirectoryEntry</a>* de, DWORD chainSize, DWORD secSize, BYTE* buf) {</div>
<div class="line">   dst[0] = de-&gt;<a class="code hl_variable" href="struct_directory_entry.html#a2411a9de48b2a41b6f092f857921d47e">startingSecLoc</a>;</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; chainSize; i++) {</div>
<div class="line">       DWORD curFATSecIndex = dst[i - 1] / (secSize / 4);</div>
<div class="line">    DWORD* fat = <span class="keyword">new</span> DWORD[secSize / 4];</div>
<div class="line">    <a class="code hl_function" href="#ac462abe109e1ef9562149cb5362f87b5">ReadSector</a>(fat, buf, fatCh[curFATSecIndex], secSize);</div>
<div class="line">    dst[i] = fat[dst[i - 1] % (secSize / 4)];</div>
<div class="line">    <span class="keyword">delete</span>[] fat;</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="ttc" id="a_x_l_s_parser_8cpp_html_a3835c3169fc0f7dd1ef7f64c5273d877"><div class="ttname"><a href="#a3835c3169fc0f7dd1ef7f64c5273d877">getWorkbookChain</a></div><div class="ttdeci">void getWorkbookChain(DWORD *dst, DWORD *fatCh, DirectoryEntry *de, DWORD chainSize, DWORD secSize, BYTE *buf)</div><div class="ttdoc">Извлекает цепочку секторов книги из FAT и сохраняет их в массив.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00348">XLSParser.cpp:348</a></div></div>
<div class="ttc" id="astruct_directory_entry_html"><div class="ttname"><a href="struct_directory_entry.html">DirectoryEntry</a></div><div class="ttdoc">Представляет запись каталога в формате Compound File Binary Format (CFBF).</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00048">XLSParser.cpp:48</a></div></div>
<div class="ttc" id="astruct_directory_entry_html_a2411a9de48b2a41b6f092f857921d47e"><div class="ttname"><a href="struct_directory_entry.html#a2411a9de48b2a41b6f092f857921d47e">DirectoryEntry::startingSecLoc</a></div><div class="ttdeci">DWORD startingSecLoc</div><div class="ttdoc">Начальный сектор.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00060">XLSParser.cpp:60</a></div></div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_x_l_s_parser_8cpp_source.html#l00348">348</a> of file <a class="el" href="_x_l_s_parser_8cpp_source.html">XLSParser.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_a3835c3169fc0f7dd1ef7f64c5273d877_cgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_a3835c3169fc0f7dd1ef7f64c5273d877_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_a3835c3169fc0f7dd1ef7f64c5273d877_icgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_a3835c3169fc0f7dd1ef7f64c5273d877_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a09591ff2fbdc05f25e3569ba3da9671d" name="a09591ff2fbdc05f25e3569ba3da9671d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09591ff2fbdc05f25e3569ba3da9671d">&#9670;&#160;</a></span>getWorkbookDEOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DWORD getWorkbookDEOffset </td>
          <td>(</td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>deChain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>countDESec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>secSize</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Определяет смещение Directory Entry (DE) объекта Workbook в файле. </p>
<p>Функция сканирует цепочку секторов Directory Entry (DE), чтобы найти объект с именем "Workbook" и возвращает его смещение относительно начала файла.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deChain</td><td>Указатель на массив номеров секторов, формирующих цепочку Directory Entry. </td></tr>
    <tr><td class="paramname">countDESec</td><td>Количество секторов в цепочке Directory Entry. </td></tr>
    <tr><td class="paramname">buf</td><td>Указатель на буфер данных Compound File. </td></tr>
    <tr><td class="paramname">secSize</td><td>Размер сектора в байтах.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Смещение Directory Entry объекта Workbook. Если объект не найден, программа завершает выполнение с ошибкой. <div class="fragment"><div class="line">DWORD <a class="code hl_function" href="#a09591ff2fbdc05f25e3569ba3da9671d">getWorkbookDEOffset</a>(DWORD* deChain, DWORD countDESec, BYTE* buf, DWORD secSize) {</div>
<div class="line">   DWORD offset = 0;</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; countDESec; i++) {</div>
<div class="line">    BYTE* deSec = <span class="keyword">new</span> BYTE[secSize];</div>
<div class="line">    <a class="code hl_function" href="#ac462abe109e1ef9562149cb5362f87b5">ReadSector</a>(deSec, buf, deChain[i], secSize);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 4; j++) {</div>
<div class="line">        <a class="code hl_struct" href="struct_directory_entry.html">DirectoryEntry</a> de;</div>
<div class="line">        memcpy(&amp;de, &amp;deSec[j * 128], 128);</div>
<div class="line">        <span class="keywordflow">if</span> (wstring(de.<a class="code hl_variable" href="struct_directory_entry.html#ad664832c543de045ef1b4f48578c9c5c">dirName</a>) == L<span class="stringliteral">&quot;Workbook&quot;</span>) {</div>
<div class="line">            offset = (deChain[i] + 1) * secSize + 128 * j;</div>
<div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;Workbook found!&quot;</span> &lt;&lt; endl;</div>
<div class="line">            <span class="keywordflow">return</span> offset;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">delete</span>[] deSec;</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">if</span> (offset == 0) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Workbook wasn&#39;t found! Closing...&quot;</span> &lt;&lt; endl;</div>
<div class="line">    exit(1);</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">return</span> offset;</div>
<div class="line">}</div>
<div class="ttc" id="a_x_l_s_parser_8cpp_html_a09591ff2fbdc05f25e3569ba3da9671d"><div class="ttname"><a href="#a09591ff2fbdc05f25e3569ba3da9671d">getWorkbookDEOffset</a></div><div class="ttdeci">DWORD getWorkbookDEOffset(DWORD *deChain, DWORD countDESec, BYTE *buf, DWORD secSize)</div><div class="ttdoc">Определяет смещение Directory Entry (DE) объекта Workbook в файле.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00622">XLSParser.cpp:622</a></div></div>
<div class="ttc" id="astruct_directory_entry_html_ad664832c543de045ef1b4f48578c9c5c"><div class="ttname"><a href="struct_directory_entry.html#ad664832c543de045ef1b4f48578c9c5c">DirectoryEntry::dirName</a></div><div class="ttdeci">WCHAR dirName[32]</div><div class="ttdoc">Имя директории.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00049">XLSParser.cpp:49</a></div></div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_x_l_s_parser_8cpp_source.html#l00622">622</a> of file <a class="el" href="_x_l_s_parser_8cpp_source.html">XLSParser.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_a09591ff2fbdc05f25e3569ba3da9671d_cgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_a09591ff2fbdc05f25e3569ba3da9671d_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_a09591ff2fbdc05f25e3569ba3da9671d_icgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_a09591ff2fbdc05f25e3569ba3da9671d_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a1f60f20a364269797af8f667e0e0d3dd" name="a1f60f20a364269797af8f667e0e0d3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f60f20a364269797af8f667e0e0d3dd">&#9670;&#160;</a></span>isEqualArr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isEqualArr </td>
          <td>(</td>
          <td class="paramtype">BYTE *</td>          <td class="paramname"><span class="paramname"><em>arr1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *</td>          <td class="paramname"><span class="paramname"><em>arr2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Сравнивает два массива байтов на равенство. </p>
<p>Функция проверяет, идентичны ли два массива байтов указанного размера. Массивы считаются одинаковыми, если все элементы в них совпадают по порядку.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr1</td><td>Указатель на первый массив байтов. </td></tr>
    <tr><td class="paramname">arr2</td><td>Указатель на второй массив байтов. </td></tr>
    <tr><td class="paramname">size</td><td>Размер массивов, который должен быть одинаковым для обоих массивов.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code>, если массивы идентичны, <code>false</code>, если хотя бы один элемент в массивах не совпадает. <div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="#a1f60f20a364269797af8f667e0e0d3dd">isEqualArr</a>(BYTE* arr1, BYTE* arr2, DWORD size) {</div>
<div class="line">   <span class="keywordtype">bool</span> f = <span class="keyword">true</span>;</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {</div>
<div class="line">    <span class="keywordflow">if</span> (arr1[i] != arr2[i]) {</div>
<div class="line">        f = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">return</span> f;</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_x_l_s_parser_8cpp_source.html#l00187">187</a> of file <a class="el" href="_x_l_s_parser_8cpp_source.html">XLSParser.cpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_a1f60f20a364269797af8f667e0e0d3dd_icgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_a1f60f20a364269797af8f667e0e0d3dd_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ae66f6b31b5ad750f1fe042a706a4e3d4" name="ae66f6b31b5ad750f1fe042a706a4e3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66f6b31b5ad750f1fe042a706a4e3d4">&#9670;&#160;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_x_l_s_parser_8cpp_source.html#l00998">998</a> of file <a class="el" href="_x_l_s_parser_8cpp_source.html">XLSParser.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4_cgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a700d13c54a8be00c596a541be2dc97ce" name="a700d13c54a8be00c596a541be2dc97ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700d13c54a8be00c596a541be2dc97ce">&#9670;&#160;</a></span>openFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HANDLE openFile </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Открывает файл для чтения. </p>
<p>Функция открывает файл с указанным именем для чтения с использованием Windows API. Если файл успешно открыт, возвращается дескриптор файла. В случае ошибки при открытии файла выводится сообщение об ошибке, и программа завершает выполнение.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Указатель на строку, содержащую имя файла, который необходимо открыть.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Возвращает дескриптор открытого файла в случае успеха. <div class="fragment"><div class="line">HANDLE <a class="code hl_function" href="#a700d13c54a8be00c596a541be2dc97ce">openFile</a>(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* filename) {</div>
<div class="line">   HANDLE fileHandle = CreateFile(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);</div>
<div class="line">   <span class="keywordflow">if</span> (fileHandle == INVALID_HANDLE_VALUE) {</div>
<div class="line">    wcout &lt;&lt; L<span class="stringliteral">&quot;Ошибка открытия файла!&quot;</span> &lt;&lt; endl;</div>
<div class="line">    CloseHandle(fileHandle);</div>
<div class="line">    exit(1);</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">return</span> fileHandle;</div>
<div class="line">}</div>
<div class="ttc" id="a_x_l_s_parser_8cpp_html_a700d13c54a8be00c596a541be2dc97ce"><div class="ttname"><a href="#a700d13c54a8be00c596a541be2dc97ce">openFile</a></div><div class="ttdeci">HANDLE openFile(const wchar_t *filename)</div><div class="ttdoc">Открывает файл для чтения.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00383">XLSParser.cpp:383</a></div></div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_x_l_s_parser_8cpp_source.html#l00383">383</a> of file <a class="el" href="_x_l_s_parser_8cpp_source.html">XLSParser.cpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_a700d13c54a8be00c596a541be2dc97ce_icgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_a700d13c54a8be00c596a541be2dc97ce_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a2f9c788c5e66bfc234d597ce3e4ca7fe" name="a2f9c788c5e66bfc234d597ce3e4ca7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9c788c5e66bfc234d597ce3e4ca7fe">&#9670;&#160;</a></span>printSheetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void printSheetName </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="struct_bound_sheet8.html">BoundSheet8</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>bsv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Выводит имя листа из вектора <a class="el" href="struct_bound_sheet8.html" title="Структура для представления метаданных о листе в файле Excel.">BoundSheet8</a>. </p>
<p>Функция принимает вектор объектов <a class="el" href="struct_bound_sheet8.html" title="Структура для представления метаданных о листе в файле Excel.">BoundSheet8</a>, индекс листа и выводит его имя на консоль. Поддерживает как ANSI, так и Unicode кодировки.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bsv</td><td>Вектор объектов <a class="el" href="struct_bound_sheet8.html" title="Структура для представления метаданных о листе в файле Excel.">BoundSheet8</a>, содержащих метаданные листов. </td></tr>
    <tr><td class="paramname">i</td><td>Индекс листа, имя которого требуется вывести. <div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="#a2f9c788c5e66bfc234d597ce3e4ca7fe">printSheetName</a>(vector&lt;BoundSheet8&gt; bsv, DWORD i) {</div>
<div class="line">   <span class="keywordflow">if</span> (bsv[i].name.fHighByte == 0) {</div>
<div class="line">    cout &lt;&lt; string((<span class="keyword">const</span> <span class="keywordtype">char</span>*)bsv[i].name.rgb.data()) &lt;&lt; endl;</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">else</span> {</div>
<div class="line">    wcout &lt;&lt; wstring((<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>*)bsv[i].name.rgb.data()) &lt;&lt; endl;</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="ttc" id="a_x_l_s_parser_8cpp_html_a2f9c788c5e66bfc234d597ce3e4ca7fe"><div class="ttname"><a href="#a2f9c788c5e66bfc234d597ce3e4ca7fe">printSheetName</a></div><div class="ttdeci">void printSheetName(vector&lt; BoundSheet8 &gt; bsv, DWORD i)</div><div class="ttdoc">Выводит имя листа из вектора BoundSheet8.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00788">XLSParser.cpp:788</a></div></div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_x_l_s_parser_8cpp_source.html#l00788">788</a> of file <a class="el" href="_x_l_s_parser_8cpp_source.html">XLSParser.cpp</a>.</p>

</div>
</div>
<a id="aacd1dfd77f1b9ad3b1c65d31f50d1800" name="aacd1dfd77f1b9ad3b1c65d31f50d1800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd1dfd77f1b9ad3b1c65d31f50d1800">&#9670;&#160;</a></span>printXLURES()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void printXLURES </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_s_t.html">SST</a> *</td>          <td class="paramname"><span class="paramname"><em>sst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Печатает строку <a class="el" href="struct_x_l_u_r_e_s.html" title="Представляет строку в формате BIFF (Binary Interchange File Format) Excel.">XLURES</a> из таблицы <a class="el" href="struct_s_s_t.html" title="Структура, представляющая таблицу строк (String Table) в формате BIFF (Binary Interchange File Format...">SST</a>. </p>
<p>Функция принимает объект <a class="el" href="struct_s_s_t.html" title="Структура, представляющая таблицу строк (String Table) в формате BIFF (Binary Interchange File Format...">SST</a> и индекс строки, после чего выводит строку на консоль. Строка может быть представлена либо в однобайтовой (ASCII), либо в двухбайтовой (Unicode) кодировке.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sst</td><td>Указатель на объект <a class="el" href="struct_s_s_t.html" title="Структура, представляющая таблицу строк (String Table) в формате BIFF (Binary Interchange File Format...">SST</a>, содержащий строки. </td></tr>
    <tr><td class="paramname">i</td><td>Индекс строки в таблице <a class="el" href="struct_s_s_t.html" title="Структура, представляющая таблицу строк (String Table) в формате BIFF (Binary Interchange File Format...">SST</a>. <div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="#aacd1dfd77f1b9ad3b1c65d31f50d1800">printXLURES</a>(<a class="code hl_struct" href="struct_s_s_t.html">SST</a>* sst, DWORD i) {</div>
<div class="line">   <a class="code hl_struct" href="struct_x_l_u_r_e_s.html">XLURES</a> str = sst-&gt;<a class="code hl_variable" href="struct_s_s_t.html#a18e2f91f34feefe5f02c5c0be159c9de">strings</a>[i];</div>
<div class="line">   <span class="keywordflow">if</span> (str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a2aef779a1eb92333dfc17816ff9ec4d7">fHighByte</a> == 0) {</div>
<div class="line">    cout &lt;&lt; string((<span class="keyword">const</span> <span class="keywordtype">char</span>*)str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a13abc96352f1a4f7f5be0fda9429d0c5">rgb</a>.data(), str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#affb254823ba2974e33e6538e5a3919a0">cch</a>) &lt;&lt; endl;</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">else</span> {</div>
<div class="line">    wcout &lt;&lt; wstring((<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>*)str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#a13abc96352f1a4f7f5be0fda9429d0c5">rgb</a>.data(), str.<a class="code hl_variable" href="struct_x_l_u_r_e_s.html#affb254823ba2974e33e6538e5a3919a0">cch</a>) &lt;&lt; endl;</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="ttc" id="a_x_l_s_parser_8cpp_html_aacd1dfd77f1b9ad3b1c65d31f50d1800"><div class="ttname"><a href="#aacd1dfd77f1b9ad3b1c65d31f50d1800">printXLURES</a></div><div class="ttdeci">void printXLURES(SST *sst, DWORD i)</div><div class="ttdoc">Печатает строку XLURES из таблицы SST.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00988">XLSParser.cpp:988</a></div></div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_x_l_s_parser_8cpp_source.html#l00988">988</a> of file <a class="el" href="_x_l_s_parser_8cpp_source.html">XLSParser.cpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_aacd1dfd77f1b9ad3b1c65d31f50d1800_icgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_aacd1dfd77f1b9ad3b1c65d31f50d1800_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="aff033cf1fdd9f4bdae4177c562eaa5c7" name="aff033cf1fdd9f4bdae4177c562eaa5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff033cf1fdd9f4bdae4177c562eaa5c7">&#9670;&#160;</a></span>readHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_f_header.html">CFHeader</a> * readHeader </td>
          <td>(</td>
          <td class="paramtype">BYTE *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Читает заголовок из буфера и возвращает указатель на структуру <a class="el" href="struct_c_f_header.html" title="Представляет заголовок Compound File (CF), используемый в формате Compound File Binary Format (CFBF).">CFHeader</a>. </p>
<p>Функция выделяет память для структуры <code><a class="el" href="struct_c_f_header.html" title="Представляет заголовок Compound File (CF), используемый в формате Compound File Binary Format (CFBF).">CFHeader</a></code>, копирует данные из буфера в структуру и возвращает указатель на эту структуру.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Указатель на буфер, содержащий данные заголовка.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Указатель на структуру <a class="el" href="struct_c_f_header.html" title="Представляет заголовок Compound File (CF), используемый в формате Compound File Binary Format (CFBF).">CFHeader</a>, заполненную данными из буфера. <div class="fragment"><div class="line"><a class="code hl_struct" href="struct_c_f_header.html">CFHeader</a>* <a class="code hl_function" href="#aff033cf1fdd9f4bdae4177c562eaa5c7">readHeader</a>(BYTE* buf) {</div>
<div class="line">   <a class="code hl_struct" href="struct_c_f_header.html">CFHeader</a>* cfh = <span class="keyword">new</span> <a class="code hl_struct" href="struct_c_f_header.html">CFHeader</a>;</div>
<div class="line">   memcpy(cfh, &amp;buf[0], <span class="keyword">sizeof</span>(<a class="code hl_struct" href="struct_c_f_header.html">CFHeader</a>));</div>
<div class="line">   <span class="keywordflow">return</span> cfh;</div>
<div class="line">}</div>
<div class="ttc" id="a_x_l_s_parser_8cpp_html_aff033cf1fdd9f4bdae4177c562eaa5c7"><div class="ttname"><a href="#aff033cf1fdd9f4bdae4177c562eaa5c7">readHeader</a></div><div class="ttdeci">CFHeader * readHeader(BYTE *buf)</div><div class="ttdoc">Читает заголовок из буфера и возвращает указатель на структуру CFHeader.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00452">XLSParser.cpp:452</a></div></div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_x_l_s_parser_8cpp_source.html#l00452">452</a> of file <a class="el" href="_x_l_s_parser_8cpp_source.html">XLSParser.cpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_aff033cf1fdd9f4bdae4177c562eaa5c7_icgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_aff033cf1fdd9f4bdae4177c562eaa5c7_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ac462abe109e1ef9562149cb5362f87b5" name="ac462abe109e1ef9562149cb5362f87b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac462abe109e1ef9562149cb5362f87b5">&#9670;&#160;</a></span>ReadSector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ReadSector </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>secNum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Читает данные сектора из буфера в указанную область памяти. </p>
<p>Функция копирует данные сектора из буфера в указанную область памяти. Сектор определяется его номером и размером, который задается в параметре.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Указатель на область памяти, в которую будут записаны данные сектора. </td></tr>
    <tr><td class="paramname">buf</td><td>Указатель на буфер, содержащий данные всех секторов. </td></tr>
    <tr><td class="paramname">secNum</td><td>Номер сектора, данные которого нужно извлечь. </td></tr>
    <tr><td class="paramname">size</td><td>Размер сектора в байтах. <div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code hl_function" href="#ac462abe109e1ef9562149cb5362f87b5">ReadSector</a>(<span class="keywordtype">void</span>* dst, BYTE* buf, DWORD secNum, DWORD size) {</div>
<div class="line">   memcpy(dst, &amp;buf[(secNum + 1) * size], size);</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_x_l_s_parser_8cpp_source.html#l00215">215</a> of file <a class="el" href="_x_l_s_parser_8cpp_source.html">XLSParser.cpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_ac462abe109e1ef9562149cb5362f87b5_icgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_ac462abe109e1ef9562149cb5362f87b5_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="aa1c59453319a7175976aa689a12ecd94" name="aa1c59453319a7175976aa689a12ecd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c59453319a7175976aa689a12ecd94">&#9670;&#160;</a></span>unpackWBSC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE * unpackWBSC </td>
          <td>(</td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>wkbkSC</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>wbSSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>secSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Распаковывает цепочку секторов Workbook в единый непрерывный буфер. </p>
<p>Функция читает данные из цепочки секторов, принадлежащих Workbook, и объединяет их в непрерывный массив байтов.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wkbkSC</td><td>Указатель на массив номеров секторов, составляющих цепочку Workbook. </td></tr>
    <tr><td class="paramname">wbSSize</td><td>Количество секторов в цепочке Workbook. </td></tr>
    <tr><td class="paramname">secSize</td><td>Размер сектора в байтах. </td></tr>
    <tr><td class="paramname">buf</td><td>Указатель на буфер данных Compound File.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Указатель на новый буфер, содержащий данные из всех секторов Workbook. <div class="fragment"><div class="line">BYTE* <a class="code hl_function" href="#aa1c59453319a7175976aa689a12ecd94">unpackWBSC</a>(DWORD* wkbkSC, DWORD wbSSize, DWORD secSize, BYTE* buf) {</div>
<div class="line">   BYTE* unp = <span class="keyword">new</span> BYTE[wbSSize * secSize];</div>
<div class="line">   DWORD offset = 0;</div>
<div class="line">   <span class="keywordflow">for</span> (DWORD i = 0; i &lt; wbSSize; i++) {</div>
<div class="line">    <a class="code hl_function" href="#ac462abe109e1ef9562149cb5362f87b5">ReadSector</a>(&amp;unp[offset], buf, wkbkSC[i], secSize);</div>
<div class="line">    offset += secSize;</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">return</span> unp;</div>
<div class="line">}</div>
<div class="ttc" id="a_x_l_s_parser_8cpp_html_aa1c59453319a7175976aa689a12ecd94"><div class="ttname"><a href="#aa1c59453319a7175976aa689a12ecd94">unpackWBSC</a></div><div class="ttdeci">BYTE * unpackWBSC(DWORD *wkbkSC, DWORD wbSSize, DWORD secSize, BYTE *buf)</div><div class="ttdoc">Распаковывает цепочку секторов Workbook в единый непрерывный буфер.</div><div class="ttdef"><b>Definition</b> <a href="_x_l_s_parser_8cpp_source.html#l00670">XLSParser.cpp:670</a></div></div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_x_l_s_parser_8cpp_source.html#l00670">670</a> of file <a class="el" href="_x_l_s_parser_8cpp_source.html">XLSParser.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_aa1c59453319a7175976aa689a12ecd94_cgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_aa1c59453319a7175976aa689a12ecd94_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_x_l_s_parser_8cpp_aa1c59453319a7175976aa689a12ecd94_icgraph.png" border="0" usemap="#a_x_l_s_parser_8cpp_aa1c59453319a7175976aa689a12ecd94_icgraph" alt=""/></div>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
